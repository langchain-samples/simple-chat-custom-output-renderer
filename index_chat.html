<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat LangChain Custom Output Renderer</title>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <style>
        :root {
            /* Colors */
            --bg-primary: #f5f5f7;
            --bg-secondary: #f3f4f6;
            --bg-white: #ffffff;
            --border-light: #e5e7eb;
            --border-medium: #d1d5db;
            --border-dark: #9ca3af;
            --text-primary: #1f2937;
            --text-secondary: #374151;
            --text-muted: #6b7280;

            /* User message colors */
            --user-bg-start: #e0f2fe;
            --user-bg-end: #bae6fd;
            --user-border: #7dd3fc;
            --user-text: #0c4a6e;

            /* Assistant message colors */
            --assistant-bg-start: #f0fdf4;
            --assistant-bg-end: #dcfce7;
            --assistant-border: #86efac;
            --assistant-text: #14532d;

            /* Tool message colors */
            --tool-bg-start: #fef3c7;
            --tool-bg-end: #fde68a;
            --tool-border: #fbbf24;
            --tool-border-hover: #f59e0b;
            --tool-text: #78350f;

            /* Button colors */
            --btn-teal-bg: #14b8a6;
            --btn-teal-border: #0d9488;
            --btn-teal-hover: #0d9488;
            --btn-teal-hover-border: #0f766e;
            --btn-amber-bg: #f59e0b;
            --btn-amber-border: #d97706;
            --btn-amber-hover: #d97706;
            --btn-amber-hover-border: #b45309;

            /* Code colors */
            --code-inline-bg: rgba(0, 0, 0, 0.05);
            --code-inline-color: #991b1b;
            --syntax-keyword: #d73a49;
            --syntax-string: #22863a;
            --syntax-comment: #6a737d;
            --syntax-function: #6f42c1;
            --syntax-number: #005cc5;
            --json-key: #0369a1;
            --json-string: #15803d;
            --json-number: #0369a1;
            --json-boolean: #be123c;
            --json-null: #6b7280;

            /* Dimensions */
            --max-content-height: 400px;
            --transition-duration: 150ms;
            --debounce-delay: 50ms;

            /* Fonts */
            --font-main: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --font-mono: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, 'Liberation Mono', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-main);
            background: var(--bg-primary);
            min-height: 100vh;
            padding: 20px;
            width: 100%;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
        }

        .conversation {
            padding: 0;
            margin-bottom: 0;
            width: 100%;
            display: flex;
            flex-direction: column;
            opacity: 1;
            transition: opacity 0.15s ease-in-out;
        }

        .conversation.updating {
            opacity: 0.3;
        }

        .conversation.initial-load {
            opacity: 0;
        }

        .message {
            display: flex;
            width: 100%;
            margin-bottom: 20px;
            padding: 0;
            animation: fadeIn 0.3s ease-out;
        }

        @media (prefers-reduced-motion: reduce) {
            .message {
                animation: none;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user,
        .message.human {
            justify-content: flex-start;
            text-align: left;
        }

        .message.assistant,
        .message.ai,
        .message.tool {
            justify-content: flex-end;
            text-align: right;
        }

        .message-bubble {
            max-width: 75%;
            padding: 16px 18px;
            border-radius: 18px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            text-align: left;
            display: inline-block;
        }

        .message.user .message-bubble,
        .message.human .message-bubble {
            background: linear-gradient(135deg, var(--user-bg-start) 0%, var(--user-bg-end) 100%);
            border-bottom-left-radius: 4px;
            margin-right: auto;
            border: 1px solid var(--user-border);
        }

        .message.assistant .message-bubble,
        .message.ai .message-bubble {
            background: linear-gradient(135deg, var(--assistant-bg-start) 0%, var(--assistant-bg-end) 100%);
            border-bottom-right-radius: 4px;
            margin-left: auto;
            border: 1px solid var(--assistant-border);
        }

        .message.tool .message-bubble {
            background: linear-gradient(135deg, var(--tool-bg-start) 0%, var(--tool-bg-end) 100%);
            border: 1px solid var(--tool-border);
            border-bottom-right-radius: 4px;
            margin-left: auto;
        }

        .message.tool .message-bubble:hover {
            border-color: var(--tool-border-hover);
        }

        .tool-toggle {
            display: inline-block;
            margin-left: 8px;
            padding: 2px 6px;
            background: var(--btn-amber-bg);
            border-radius: 4px;
            font-size: 10px;
            color: var(--tool-text);
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid var(--btn-amber-border);
            font-weight: 600;
        }

        .tool-toggle:hover {
            background: var(--btn-amber-hover);
            color: var(--tool-text);
            border-color: var(--btn-amber-hover-border);
        }

        /* Shared scrollbar styles */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: var(--border-medium);
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: var(--border-dark);
        }

        .tool-content {
            margin-top: 8px;
            max-height: var(--max-content-height);
            overflow-y: auto;
            background: var(--bg-white);
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            padding: 12px;
            font-size: 13px;
            color: var(--text-primary);
            line-height: 1.5;
            font-family: var(--font-mono);
        }

        .tool-content.collapsed {
            display: none;
        }

        /* Common pre styles */
        .tool-content pre,
        .raw-view pre,
        .json-container pre,
        .tool-result .json-container pre {
            margin: 0;
            padding: 0;
            background: transparent;
            border: none;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .message-role .raw-toggle {
            display: inline-block;
            margin-left: 8px;
            padding: 4px 8px;
            background: var(--btn-teal-bg);
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid var(--btn-teal-border);
            color: var(--bg-white);
            font-weight: 600;
        }

        .message-role .raw-toggle:hover {
            background: var(--btn-teal-hover);
            border-color: var(--btn-teal-hover-border);
            color: var(--bg-white);
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(20, 184, 166, 0.3);
        }

        .message-role button {
            background: none;
            font-family: inherit;
        }

        .raw-view {
            overflow-x: auto;
            font-family: var(--font-mono);
            font-size: 12px;
            line-height: 1.5;
            color: var(--text-primary);
        }

        .message:not(.tool) .raw-view {
            margin-top: 12px;
            background: var(--bg-white);
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            padding: 12px;
        }

        .hidden {
            display: none;
        }

        .message-role {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .message.user .message-role {
            color: var(--user-text);
        }

        .message.assistant .message-role {
            color: var(--assistant-text);
        }

        .message.tool .message-role {
            color: var(--tool-text);
        }

        .message-content {
            color: var(--text-primary);
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 15px;
        }

        .message.tool .message-content {
            color: var(--text-secondary);
        }

        /* Markdown Styling */
        .markdown-content {
            color: var(--text-primary);
        }

        .message.tool .markdown-content {
            color: var(--text-secondary);
        }

        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4,
        .markdown-content h5,
        .markdown-content h6 {
            margin-top: 16px;
            margin-bottom: 10px;
            font-weight: 600;
            line-height: 1.25;
        }

        .markdown-content h1:first-child,
        .markdown-content h2:first-child,
        .markdown-content h3:first-child {
            margin-top: 0;
        }

        .markdown-content h1 { font-size: 1.5em; }
        .markdown-content h2 { font-size: 1.3em; }
        .markdown-content h3 { font-size: 1.15em; }

        .markdown-content p {
            margin-bottom: 12px;
        }

        .markdown-content p:last-child {
            margin-bottom: 0;
        }

        .markdown-content ul,
        .markdown-content ol {
            margin-left: 20px;
            margin-bottom: 12px;
        }

        .markdown-content ul:last-child,
        .markdown-content ol:last-child {
            margin-bottom: 0;
        }

        .markdown-content li {
            margin-bottom: 6px;
        }

        .markdown-content code {
            background: var(--code-inline-bg);
            padding: 2px 6px;
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 0.85em;
            color: var(--code-inline-color);
        }

        .markdown-content pre {
            background: var(--bg-white);
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin-bottom: 12px;
            border: 1px solid var(--border-medium);
        }

        .markdown-content pre code {
            background: none;
            padding: 0;
            color: var(--text-primary);
            font-size: 13px;
            line-height: 1.5;
            font-family: var(--font-mono);
        }

        /* Syntax highlighting */
        .markdown-content pre code .keyword { color: var(--syntax-keyword); }
        .markdown-content pre code .string { color: var(--syntax-string); }
        .markdown-content pre code .comment { color: var(--syntax-comment); font-style: italic; }
        .markdown-content pre code .function { color: var(--syntax-function); }
        .markdown-content pre code .number { color: var(--syntax-number); }

        .markdown-content a {
            color: #2563eb;
            text-decoration: underline;
        }

        .markdown-content a:hover {
            color: #1d4ed8;
        }

        .markdown-content blockquote {
            border-left: 4px solid var(--border-medium);
            padding-left: 16px;
            margin: 12px 0;
            opacity: 0.9;
        }

        .markdown-content table {
            border-collapse: collapse;
            margin-bottom: 12px;
            width: 100%;
        }

        .markdown-content th,
        .markdown-content td {
            border: 1px solid var(--border-medium);
            padding: 8px 12px;
            text-align: left;
        }

        .markdown-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        /* JSON Syntax Highlighting */
        .json-container {
            background: var(--bg-white);
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: var(--font-mono);
            font-size: 13px;
            line-height: 1.5;
            border: 1px solid var(--border-medium);
            color: var(--text-primary);
        }

        .json-key {
            color: var(--json-key);
        }

        .json-string {
            color: var(--json-string);
        }

        .json-number {
            color: var(--json-number);
        }

        .json-boolean {
            color: var(--json-boolean);
        }

        .json-null {
            color: var(--json-null);
        }

        .tool-calls {
            margin-top: 15px;
        }

        .tool-call {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid var(--border-medium);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .tool-call-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .tool-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--tool-text);
            font-family: var(--font-mono);
        }

        .tool-id {
            font-size: 11px;
            color: var(--text-muted);
            font-family: var(--font-mono);
        }

        .tool-arguments {
            font-size: 13px;
            font-family: var(--font-mono);
            margin-top: 8px;
            padding: 12px;
            background: var(--bg-white);
            border-radius: 6px;
            border: 1px solid var(--border-medium);
            overflow-x: auto;
            line-height: 1.5;
            color: var(--text-primary);
        }

        .tool-result {
            max-height: var(--max-content-height);
            overflow-y: auto;
            background: var(--bg-white);
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
            font-size: 13px;
            color: var(--text-primary);
            line-height: 1.5;
            font-family: var(--font-mono);
        }

        .tool-result .markdown-content {
            font-family: var(--font-main);
            color: var(--text-secondary);
        }

    </style>
</head>
<body>
    <div class="container">
        <div id="conversations"></div>
    </div>

    <script>
        // Wrap in IIFE to avoid global namespace pollution
        (function() {
            'use strict';

            const DEBUG = false;
            const conversationsContainer = document.getElementById('conversations');
            let messageCounter = 0;

            // Constants
            const ROLE_DISPLAY_NAMES = {
                'user': 'Human',
                'human': 'Human',
                'assistant': 'AI Assistant',
                'ai': 'AI Assistant',
                'tool': 'Tool',
                'unknown': 'Unknown'
            };

            const KEYWORDS_BY_LANG = {
                javascript: /\b(const|let|var|function|return|if|else|for|while|class|import|export|from|async|await|try|catch|new|this)\b/g,
                python: /\b(def|class|import|from|return|if|else|elif|for|while|try|except|with|as|async|await|lambda|in|and|or|not|is|True|False|None)\b/g,
                typescript: /\b(const|let|var|function|return|if|else|for|while|class|interface|type|import|export|from|async|await|try|catch|new|this)\b/g,
                js: /\b(const|let|var|function|return|if|else|for|while|class|import|export|from|async|await|try|catch|new|this)\b/g,
                ts: /\b(const|let|var|function|return|if|else|for|while|class|interface|type|import|export|from|async|await|try|catch|new|this)\b/g,
                py: /\b(def|class|import|from|return|if|else|elif|for|while|try|except|with|as|async|await|lambda|in|and|or|not|is|True|False|None)\b/g
            };

            const CONTENT_FIELDS = ['answer', 'output', 'text', 'content', 'output_answer', 'message', 'response', 'result'];

            // Security: HTML escape function to prevent XSS
            function escapeHtml(text) {
                if (text == null) return '';
                const div = document.createElement('div');
                div.textContent = String(text);
                return div.innerHTML;
            }

            // Safely stringify objects, handling circular references
            function safeStringify(obj, indent = 2) {
                try {
                    return JSON.stringify(obj, null, indent);
                } catch (e) {
                    if (DEBUG) console.warn('[safeStringify] Circular reference:', e);
                    return '[Unable to serialize: circular reference or non-serializable object]';
                }
            }

            // Simple syntax highlighting function
            function highlightCode(code, lang) {
                code = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                // Match strings (limit length to prevent catastrophic backtracking)
                const stringMatches = [];
                let stringIndex = 0;
                code = code.replace(/(["'`])((?:\\.|[^"'`\\]){0,1000}?)\1/g, (match) => {
                    const placeholder = `__STRING_${stringIndex}__`;
                    stringMatches[stringIndex] = `<span class="string">${match}</span>`;
                    stringIndex++;
                    return placeholder;
                });

                // Match comments
                const commentMatches = [];
                let commentIndex = 0;
                code = code.replace(/(#.*$|\/\/.*$|\/\*[\s\S]*?\*\/)/gm, (match) => {
                    const placeholder = `__COMMENT_${commentIndex}__`;
                    commentMatches[commentIndex] = `<span class="comment">${match}</span>`;
                    commentIndex++;
                    return placeholder;
                });

                // Highlight keywords
                const keywordPattern = KEYWORDS_BY_LANG[lang] || KEYWORDS_BY_LANG.javascript;
                code = code.replace(keywordPattern, '<span class="keyword">$1</span>');

                // Highlight numbers
                code = code.replace(/\b\d+(\.\d+)?\b/g, '<span class="number">$&</span>');

                // Restore strings and comments
                stringMatches.forEach((match, i) => code = code.replace(`__STRING_${i}__`, match));
                commentMatches.forEach((match, i) => code = code.replace(`__COMMENT_${i}__`, match));

                return code;
            }

            // Wait for marked to load, then initialize
            function initializeMarked() {
                if (typeof marked !== 'undefined') {
                    try {
                        console.log('Initializing marked, version:', marked.version || 'unknown');

                        // Create custom renderer
                        const renderer = {
                            code(code, language) {
                                const lang = (language || 'text').toLowerCase();
                                const highlighted = lang === 'json' ? syntaxHighlightJSON(code) : highlightCode(code, lang);
                                return `<pre><code class="language-${lang}">${highlighted}</code></pre>`;
                            }
                        };

                        // Configure marked with the renderer
                        marked.use({ renderer });
                        console.log('Marked configured successfully');
                    } catch (e) {
                        console.error('Could not configure marked renderer:', e);
                    }
                } else {
                    console.error('marked library not available!');
                }
            }

            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initializeMarked);
            } else {
                initializeMarked();
            }

            // Parse markdown with syntax highlighting
            function parseMarkdown(text) {
                if (typeof marked === 'undefined') {
                    console.warn('marked library not loaded!');
                    return text;
                }

                try {
                    // Use marked.parse() for version 11.x
                    if (typeof marked.parse === 'function') {
                        return marked.parse(text, { breaks: true, gfm: true });
                    } else if (typeof marked === 'function') {
                        return marked(text, { breaks: true, gfm: true });
                    } else {
                        console.error('Cannot find marked parsing function');
                        return text;
                    }
                } catch (e) {
                    console.error('Markdown parse error:', e, 'Input:', text.substring(0, 100));
                    return text;
                }
            }

            function isJSON(str) {
                if (typeof str !== 'string') return false;
                try {
                    const result = JSON.parse(str);
                    return typeof result === 'object' && result !== null;
                } catch (e) {
                    return false;
                }
            }

            function syntaxHighlightJSON(json) {
                if (typeof json !== 'string') {
                    json = JSON.stringify(json, null, 2);
                } else {
                    try {
                        const parsed = JSON.parse(json);
                        json = JSON.stringify(parsed, null, 2);
                    } catch (e) {
                        console.warn('Failed to parse JSON for formatting:', e);
                    }
                }

                json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

                return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
                    let cls = 'json-number';
                    if (/^"/.test(match)) {
                        cls = /:$/.test(match) ? 'json-key' : 'json-string';
                    } else if (/true|false/.test(match)) {
                        cls = 'json-boolean';
                    } else if (/null/.test(match)) {
                        cls = 'json-null';
                    }
                    return '<span class="' + cls + '">' + match + '</span>';
                });
            }

            // Helper to extract text from common field names
            function extractTextField(obj) {
                for (const field of CONTENT_FIELDS) {
                    const value = obj[field];
                    if (typeof value === 'string' && value.trim()) {
                        return value;
                    }
                }
                return null;
            }

            function formatContent(content) {
                if (!content) return '';

                // Check if content is an array of content blocks (LangChain structure)
                if (Array.isArray(content)) {
                    const textParts = [];
                    content.forEach(block => {
                        if (block && block.type === 'text' && block.text) {
                            textParts.push(block.text);
                        } else if (typeof block === 'string') {
                            textParts.push(block);
                        } else if (block && block.type === 'tool_use' && DEBUG) {
                            console.log('[formatContent] Skipping tool_use block:', block.name);
                        }
                    });

                    const textContent = textParts.join('');
                    if (textContent) {
                        const html = parseMarkdown(textContent);
                        return `<div class="markdown-content">${html}</div>`;
                    }

                    const formatted = syntaxHighlightJSON(content);
                    return `<div class="json-container"><pre>${formatted}</pre></div>`;
                }

                // If content is an object, try to extract text from common fields
                if (typeof content === 'object') {
                    const textField = extractTextField(content);
                    if (textField) {
                        if (DEBUG) console.log('[formatContent] Extracting text from object:', textField.substring(0, 100));
                        const html = parseMarkdown(textField);
                        return `<div class="markdown-content">${html}</div>`;
                    }

                    const formatted = syntaxHighlightJSON(content);
                    return `<div class="json-container"><pre>${formatted}</pre></div>`;
                }

                // Check if entire content is pure JSON string
                if (isJSON(content)) {
                    try {
                        const parsed = JSON.parse(content);
                        const textField = extractTextField(parsed);
                        if (textField) {
                            if (DEBUG) console.log('[formatContent] Extracting text from JSON string:', textField.substring(0, 100));
                            const html = parseMarkdown(textField);
                            return `<div class="markdown-content">${html}</div>`;
                        }
                    } catch (e) {
                        if (DEBUG) console.warn('[formatContent] Failed to extract from JSON string:', e);
                    }

                    const formatted = syntaxHighlightJSON(content);
                    return `<div class="json-container"><pre>${formatted}</pre></div>`;
                }

                // Default: parse as markdown
                const html = parseMarkdown(content);
                return `<div class="markdown-content">${html}</div>`;
            }

            function renderMessage(message, index) {
                if (DEBUG) console.log('[renderMessage]', message);

                const role = message.role || message.type || 'unknown';
                const messageId = `msg-${messageCounter++}`;
                const rawId = `raw-${messageId}`;
                const renderedId = `rendered-${messageId}`;
                const displayRole = ROLE_DISPLAY_NAMES[role] || escapeHtml(role);
                const escapedName = message.name ? ` (${escapeHtml(message.name)})` : '';

                const roleHeader = `
                    <div class="message-role">
                        <span>${displayRole}${escapedName}</span>
                        ${role !== 'tool' ? `<button class="raw-toggle" onclick="event.stopPropagation(); toggleRaw('${rawId}', '${renderedId}')" aria-label="Toggle raw JSON view" aria-expanded="false" aria-controls="${rawId}">{ } Raw</button>` : ''}
                        ${role === 'tool' ? `<button class="tool-toggle" onclick="event.stopPropagation(); toggleTool('${messageId}')" aria-label="Expand tool output" aria-expanded="false" aria-controls="${messageId}">▼ Expand</button>` : ''}
                    </div>
                `;

                let renderedHTML = '';

                // Skip rendered view for tool messages (they only show raw JSON)
                if (role !== 'tool') {
                    // Format content
                    if (message.content) {
                        renderedHTML += formatContent(message.content);
                    }

                    // Tool calls (for assistant messages)
                    if (message.tool_calls && message.tool_calls.length > 0) {
                        const toolCallParts = ['<div class="tool-calls">'];
                        for (let toolCall of message.tool_calls) {
                            const func = toolCall.function || toolCall;
                            const toolName = escapeHtml(func.name || toolCall.name || 'Unknown Tool');
                            const toolArgs = func.arguments || toolCall.args;
                            const toolId = escapeHtml(toolCall.id || '');

                            let argsHTML = '';
                            if (toolArgs !== undefined && toolArgs !== null) {
                                if (typeof toolArgs === 'object') {
                                    argsHTML = `<div class="tool-arguments"><pre>${syntaxHighlightJSON(toolArgs)}</pre></div>`;
                                } else if (isJSON(toolArgs)) {
                                    argsHTML = `<div class="tool-arguments"><pre>${syntaxHighlightJSON(toolArgs)}</pre></div>`;
                                } else {
                                    argsHTML = `<div class="tool-arguments">${escapeHtml(String(toolArgs))}</div>`;
                                }
                            }

                            toolCallParts.push(`
                                <div class="tool-call">
                                    <div class="tool-call-header">
                                        <span class="tool-name">${toolName}</span>
                                        <span class="tool-id">${toolId}</span>
                                    </div>
                                    ${argsHTML}
                                </div>
                            `);
                        }
                        toolCallParts.push('</div>');
                        renderedHTML += toolCallParts.join('');
                    }
                }

                const rawJSON = syntaxHighlightJSON(message);

                // Assemble final HTML
                const bubbleHTML = role === 'tool'
                    ? `${roleHeader}<div class="tool-content custom-scrollbar collapsed" id="${messageId}"><pre>${rawJSON}</pre></div>`
                    : `${roleHeader}<div class="rendered-view" id="${renderedId}">${renderedHTML}</div><div class="raw-view hidden" id="${rawId}"><pre>${rawJSON}</pre></div>`;

                return `<div class="message ${role}"><div class="message-bubble">${bubbleHTML}</div></div>`;
            }

            function toggleRaw(rawId, renderedId) {
                const rawView = document.getElementById(rawId);
                const renderedView = document.getElementById(renderedId);
                if (rawView && renderedView) {
                    rawView.classList.toggle('hidden');
                    renderedView.classList.toggle('hidden');
                } else {
                    console.error('[toggleRaw] Missing elements:', rawId, renderedId);
                }
            }

            function toggleTool(id) {
                const element = document.getElementById(id);
                if (!element) return console.error('[toggleTool] Element not found:', id);

                const bubble = element.parentElement;
                if (!bubble) return console.error('[toggleTool] Parent not found:', id);

                const toggle = bubble.querySelector('.tool-toggle');
                const isCollapsed = element.classList.toggle('collapsed');

                if (toggle) {
                    toggle.textContent = isCollapsed ? '▼ Expand' : '▲ Collapse';
                    toggle.setAttribute('aria-expanded', !isCollapsed);
                }
            }

            // Expose functions to global scope for inline event handlers
            window.toggleRaw = toggleRaw;
            window.toggleTool = toggleTool;

            let renderTimeout = null;
            let isUpdating = false;
            let isFirstMessage = true;
            let lastRenderData = null;

            function performRender(data) {
                const conversationCard = document.createElement('div');
                conversationCard.className = 'conversation';
                const messageParts = [];

                if (Array.isArray(data)) {
                    data.forEach((msg, i) => messageParts.push(renderMessage(msg, i)));
                } else if (typeof data === 'object' && (data.role || data.type)) {
                    messageParts.push(renderMessage(data, 0));
                } else if (typeof data === 'object' && data.messages && Array.isArray(data.messages)) {
                    data.messages.forEach((msg, i) => messageParts.push(renderMessage(msg, i)));
                } else if (typeof data === 'string') {
                    messageParts.push(renderMessage({ role: 'assistant', content: data, id: 'msg-' + Date.now() }, 0));
                } else {
                    messageParts.push(renderMessage({ role: 'assistant', content: safeStringify(data), id: 'msg-' + Date.now() }, 0));
                }

                const conversationHTML = messageParts.join('');

                if (!conversationHTML) {
                    console.warn('[Renderer] Unable to render data');
                    isUpdating = false;
                    return;
                }

                conversationCard.innerHTML = conversationHTML;

                const existingCard = conversationsContainer.querySelector('.conversation');
                const isFirstRender = !existingCard;

                // First render - show immediately without transition
                if (isFirstRender) {
                    conversationCard.classList.add('initial-load');
                    conversationsContainer.replaceChildren(conversationCard);
                    // Force reflow then reveal
                    void conversationCard.offsetWidth;
                    conversationCard.classList.remove('initial-load');
                    isUpdating = false;
                } else if (!isUpdating) {
                    isUpdating = true;
                    existingCard.classList.add('updating');
                    setTimeout(() => {
                        conversationsContainer.replaceChildren(conversationCard);
                        void conversationCard.offsetWidth;
                        conversationCard.classList.remove('updating');
                        isUpdating = false;
                    }, 150);
                } else {
                    conversationsContainer.replaceChildren(conversationCard);
                    isUpdating = false;
                }

                lastRenderData = data;
            }

            window.addEventListener('message', (event) => {
                console.log('[Message Event] Received:', event);
                console.log('[Message Event] event.data:', event.data);
                console.log('[Message Event] event.origin:', event.origin);

                const { data } = event.data;

                if (!data) {
                    console.warn('[Message Event] No data in event.data, ignoring');
                    return;
                }

                console.log('[Message Event] Extracted data:', data);
                console.log('[Message Event] Data type:', typeof data, Array.isArray(data) ? '(array)' : '');

                // First message renders immediately, subsequent messages are debounced
                if (isFirstMessage) {
                    isFirstMessage = false;
                    if (renderTimeout) clearTimeout(renderTimeout);
                    performRender(data);
                } else {
                    if (renderTimeout) clearTimeout(renderTimeout);
                    renderTimeout = setTimeout(() => {
                        performRender(data);
                        renderTimeout = null;
                    }, 150);
                }
            });

            // Cleanup on unload
            window.addEventListener('beforeunload', () => {
                if (renderTimeout) {
                    clearTimeout(renderTimeout);
                    renderTimeout = null;
                }
            });

            console.log('Chat LangChain Custom Output Renderer is ready!');
            console.log('Listening for postMessage events...');

        })(); // End IIFE
    </script>
</body>
</html>
